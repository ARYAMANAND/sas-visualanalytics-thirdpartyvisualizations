<!DOCTYPE html>
<html>
<head>
	<!-- Import D3.js -->
	<script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>

	<!-- Import d3-tip from (https://github.com/VACLab/d3-tip)  -->
    <script type="text/javascript" src="https://sassoftware.github.io/sas-visualanalytics-thirdpartyvisualizations/thirdPartyHelpers/d3-tip.js"></script>

	<!-- Import jQuery -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

	<!-- Import utilities  -->
	<script type="text/javascript" src="https://sassoftware.github.io/sas-visualanalytics-thirdpartyvisualizations/util/messagingUtil.js"></script>
	<script type="text/javascript" src="https://sassoftware.github.io/sas-visualanalytics-thirdpartyvisualizations/util/contentUtil.js"></script>

    <!-- Import Web Font Loader -->
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
</head>
<body>
<style type="text/css">
	html, body, svg {
		overflow: hidden;
		margin: 0px;
		width: 100%;
		height: 100%;
	}

	.data-arc.selected {
		stroke-width: 2px;
		stroke: black;
	}

	.legend-title {
		font-family: "Noto Sans", sans-serif;
		font-size: 1.0em;
		text-anchor: middle;
		alignment-baseline: hanging;
	}

	.legend-text {
		font-family: "Noto Sans", sans-serif;
		font-size: .8em;
		alignment-baseline: hanging;
	}

	.d3-tip {
		background: white;
		position: relative;
    	border: 1px solid #C4C4C4;
		border-radius: 4px;
	}

	.d3-tip:before {
		content: "";
		position: absolute;
		top: 100%;
		left: 50%;
		height: 10px;
		width: 10px;
		background: white;
		box-sizing:border-box;
		transform: rotate(45deg) translate(-50%);
		border-bottom: inherit;
		border-right: inherit;
		box-shadow: inherit;
	}

	.d3-tip-content {
		font-family: "Noto Sans", sans-serif;
		font-size: .8em;
		text-align: left;
	}
</style>

<SVG id="styled-donut"></SVG>

<script>
	"use strict";

	WebFont.load({
		google: { families: ['Noto Sans'] },
		active: fontLoaded()
	});

	function fontLoaded() {
		/*************************************************** Declare global variables ***************************************************/
		// Data variables
		var SVG_ID = "styled-donut";														// ID of SVG element
		var SAMPLE_MESSAGE = {
		    "version": "1",
		    "resultName": "dd75",
		    "rowCount": 6,
		    "availableRowCount": 6,
		    "data": [
		        [
		            "Hybrid",
		            3
		        ],
		        [
		            "Sedan",
		            262
		        ],
		        [
		            "Sports",
		            49
		        ],
		        [
		            "SUV",
		            60
		        ],
		        [
		            "Truck",
		            24
		        ],
		        [
		            "Wagon",
		            30
		        ]
		    ],
		    "columns": [
		        {
		            "name": "bi77",
		            "label": "Type",
		            "type": "string"
		        },
		        {
		            "name": "bi78",
		            "label": "Frequency",
		            "type": "number",
		            "usage": "quantitative",
		            "aggregation": "totalCount",
		            "format": {
		                "name": "COMMA",
		                "width": 12,
		                "precision": 0,
		                "formatString": "COMMA12."
		            }
		        }
		    ]
		};																					// Sample data message to render graph outside of VA for debugging
		var VA_MESSAGE;																		// Data message to be received from VA
		var VA_RESULT_NAME;																	// Result name required to send messages back to VA
		var DATA = [];																		// Data to be parsed from VA data message
		var METADATA = [];																	// Metadata to be parsed from VA data message
		var FILL = {
			"Hybrid": "#21b9b7",
			"Sedan": "#4141e0",
			"Sports":  "#7db71a",
			"SUV": "#8e2f8a",
			"Truck": "#d38506",
			"Wagon": "#0abf85"
		};																					// Fill colors keyed to labels
		var STROKE = {
			"Hybrid": "#1d9992",
			"Sedan": "#2222bc",
			"Sports": "#6a9617",
			"SUV": "#6d256d",
			"Truck": "#ba7006",
			"Wagon": "#0a9e69"
		};																					// Stroke colors keyed to labels

		// Static dimension variables
		var MARGIN = {top: 70, right: 10, bottom: 10, left: 10};							// Margin on interior edge of SVG
		var TRANS_TIME = 500;																// Duration of transitions
		var LEG_MIN_HEIGHT = 50;															// Minimum height allocated for legend
		var LEG_ROW_HEIGHT = 15;															// Height allocated for each row of legend
		var LEG_RECT_WIDTH = 12;															// Width of legend rects
		var LEG_TITLE_TOP_PAD = 5;															// Padding between chart and legend title
		var LEG_TITLE_HEIGHT;																// Height of legend title element
		var LEG_TITLE_BOT_PAD = 5;															// Padding between legend title bottom and
		var LEG_RECT_PAD = 5;																// Padding between legend rect and legend text
		var LEG_TEXT_PAD = 5;																// Padding after legend text

		// Dynamic dimension variables
		var WIDTH = window.innerWidth;														// Width of SVG element
		var HEIGHT = window.innerHeight;													// Height of SVG element
		var DRAWABLE_WIDTH = WIDTH - MARGIN.right - MARGIN.left;							// Drawable width of SVG
		var DRAWABLE_HEIGHT = HEIGHT - MARGIN.bottom - MARGIN.top;							// Drawable height of SVG
		var RADIUS = Math.min(DRAWABLE_WIDTH, DRAWABLE_HEIGHT-LEG_MIN_HEIGHT) / 2;			// Radius of pie/donut
		var LEG_HEIGHT = Math.max(LEG_MIN_HEIGHT, DRAWABLE_HEIGHT-2*RADIUS);				// Height allocated for legend
		var LEG_EL_POS = [];																// Positions of legend text elements

		// Selection and d3 variables
		var SVG;																			// SVG selection
		var TIP;																			// Tooltip generator
		var DEFS;																			// Defs element selection
		var G_CHART_AREA;																	// Chart Area Group selection
		var G_LEGEND;																		// Legend Group selection
		var PATH;																			// Path generator to create arc paths from arc data
		var GRADIENTS;																		// Gradients data-join
		var TOOL_TIPS;																		// Tool tips data-join
		var DATA_ARCS;																		// Data Arcs data-join
		var LEGEND_TITLE;																	// Legend title data-join
		var LEGEND_RECTS;																	// Legend rects data-join
		var LEGEND_TEXTS;																	// Legend texts data-join

		// Attach event for data message from VA
		va.messagingUtil.setOnDataReceivedCallback(onDataReceived);

		// If not being rendered in iFrame (outside VA), render with sample data
		if (!inIframe()) { onDataReceived(SAMPLE_MESSAGE); }

		// Listen for resize event
		va.contentUtil.setupResizeListener(drawElements);

		// Take action on received data
		function onDataReceived(messageFromVA) {
			// Initialize global data variables
			VA_MESSAGE = messageFromVA;
			VA_RESULT_NAME = messageFromVA.resultName;

			// Validate data roles
			if (!va.contentUtil.validateRoles(messageFromVA, ["string", "number"], null)) {
				va.messagingUtil.postInstructionalMessage(VA_RESULT_NAME,
					"D3 Donut Chart expects columns to be assigned in this order:\n" +
					" 1. Category (string)\n" +
					" 2. Measure (number)");
				return;
			}

			// Parse metadata from data message
			METADATA = {
				category: VA_MESSAGE.columns[0].label,
				measure: VA_MESSAGE.columns[1].label
			};

			// Parse data from 2d array to array of objects
			var total = d3.sum(VA_MESSAGE.data, function(d) { return d[1]; });
			DATA = [];
			for (var i=0, length=VA_MESSAGE.data.length; i<length; i++) {
				var currentData = d3.select("#" + VA_MESSAGE.data[i][0]);

				DATA.push({
					label: VA_MESSAGE.data[i][0],
					measure: VA_MESSAGE.data[i][1],
					startAngle: currentData.empty() ?  (i==0 ? 0 : DATA[i-1].finalEndAngle) : JSON.parse(currentData.attr("data-d")).startAngle,
					endAngle:   currentData.empty() ? ( i==0 ? ((VA_MESSAGE.data[i][1]/total)*2*Math.PI) : (DATA[i-1].finalEndAngle + (VA_MESSAGE.data[i][1]/total)*2*Math.PI)) : JSON.parse(currentData.attr("data-d")).endAngle,
					finalStartAngle: i==0 ? 0 : DATA[i-1].finalEndAngle,
					finalEndAngle: i==0 ? ((VA_MESSAGE.data[i][1]/total)*2*Math.PI) : (DATA[i-1].finalEndAngle + (VA_MESSAGE.data[i][1]/total)*2*Math.PI),
					selected: VA_MESSAGE.data[i][2]
				});
			}

			// Initialize chart if first draw, otherwise process data and update elements accordingly
			if ($("#" + SVG_ID).children().length == 0) {
				drawElements();
			}
			else {
				updateElements();
			}
		}

		// Draw elements for first time and on resize event
		function drawElements() {
			// Calculate dimensions for graph based on container dimensions
			WIDTH = window.innerWidth;
			HEIGHT = window.innerHeight;
			DRAWABLE_WIDTH = WIDTH - MARGIN.right - MARGIN.left;
			DRAWABLE_HEIGHT = HEIGHT - MARGIN.bottom - MARGIN.top;
			RADIUS = Math.min(DRAWABLE_WIDTH, DRAWABLE_HEIGHT - LEG_MIN_HEIGHT) / 2;
			LEG_HEIGHT = Math.max(LEG_MIN_HEIGHT, DRAWABLE_HEIGHT-2*RADIUS);

			// Save reference for svg
			SVG = d3.select("#" + SVG_ID)
				.attr("width", WIDTH)
				.attr("height", HEIGHT)
				.on("click", deselectAllElements);

			// Initialize tooltip
			TIP = d3.tip()
		    	.attr("class", "d3-tip")
		    	.offset([-8, 0])
		    	.html(function(d) {
					return "<table class='d3-tip-content'> <tr> <th> " + METADATA.category + "</th> <td>" + d.label + "</td> </tr>" +
						   "<tr> <th> " + METADATA.measure + "</th> <td>" + d.measure + "</td> </tr> </table>";
				});
		    SVG.call(TIP);

			// Append defs and save reference
			SVG.selectAll(".gradient-defs").data([DATA]).enter().append("defs")
				.classed("gradient-defs", true);

			DEFS = SVG.select(".gradient-defs");

			// Append/update chart-area group and save reference
			SVG.selectAll(".g-chart-area").data([DATA]).enter().append("g")
				.classed("g-chart-area", true);

			G_CHART_AREA = SVG.select(".g-chart-area")
				.attr("transform", "translate(" + (WIDTH/2) + "," + (MARGIN.top + (DRAWABLE_HEIGHT-LEG_HEIGHT)/2) + ")");

			// Append/update legend group and save reference
			SVG.selectAll(".g-legend").data([DATA]).enter().append("g")
				.classed("g-legend", true);

			G_LEGEND = SVG.select(".g-legend")
				.attr("transform", "translate(" + (MARGIN.left) + "," + (HEIGHT-MARGIN.bottom-LEG_HEIGHT) + ")");

			// Create path generator
			PATH = d3.arc().outerRadius(RADIUS).innerRadius(.7*RADIUS);

			// Create gradients
			GRADIENTS = DEFS.selectAll(".gradient").data(DATA, function(d) { return d.label; });

			GRADIENTS.enter().append("linearGradient")
				.classed("gradient", true)
				.attr("id", function(d) { return d.label + "-gradient"; })
				.attr("x1", "0%")
				.attr("x2", "100%")
				.attr("y1", "50%")
				.attr("y2", "50%")
				.each(function() {

					d3.select(this).append("stop")
					   .attr('class', 'start')
					   .attr("offset", "0%")
					   .attr("stop-color", function(d) { return FILL[d.label]; })
					   .attr("stop-opacity", 1);

					d3.select(this).append("stop")
					   .attr('class', 'end')
					   .attr("offset", "100%")
					   .attr("stop-color", function(d) { return FILL[d.label]; })
					   .attr("stop-opacity", .7);
			});

			// Create data arcs
			DATA_ARCS = G_CHART_AREA.selectAll(".data-arc").data(DATA);

			DATA_ARCS.enter().append("path")
		    	.classed("exiting", false)
				.classed("data-arc", true)
				.classed("selectable", true)
				.classed("selected", function(d) { return d.selected; })
				.attr("id", function(d) { return d.label; })
				.attr("data-d", function(d) { return JSON.stringify(d); })
				.attr("fill", function(d) { return "url(#" + (d.label) + "-gradient)"; })
				.attr("stroke-width", 1)
				.attr("stroke", function(d) { return STROKE[d.label]; })
				.on("click", function(d, i) { selectElement(d, i, this); })
		    	.on("mouseover", TIP.show)
		    	.on("mouseout", TIP.hide)
			.merge(DATA_ARCS)
				.attr("d", function(d) {
					return PATH({startAngle: d.finalStartAngle, endAngle: d.finalEndAngle});
				});

			// Create legend title
			LEGEND_TITLE = G_LEGEND.selectAll(".legend-title").data([DATA]);

			LEGEND_TITLE.enter().append("text")
				.classed("legend-title", true)
				.text(METADATA.category)
			.merge(LEGEND_TITLE)
				.attr("x", function(d, i) { return DRAWABLE_WIDTH/2 })
				.attr("y", function(d, i) { return LEG_TITLE_TOP_PAD; });

			// Compute the x y locations for legend elements
			calculateLegendDimensions();

			// Create legend rects
			LEGEND_RECTS = G_LEGEND.selectAll(".legend-rect").data(DATA, function(d) { return d.label; });

			LEGEND_RECTS.enter().append("rect")
				.classed("legend-rect", true)
				.attr("width", LEG_RECT_WIDTH)
				.attr("height", LEG_RECT_WIDTH)
				.attr("fill", function(d) { return "url(#" + (d.label) + "-gradient)"; })
				.attr("stroke-width", 1)
				.attr("stroke", function(d) { return STROKE[d.label]; })
			.merge(LEGEND_RECTS)
				.attr("x", function(d, i) { return LEG_EL_POS[i].x; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; });

			// Create legend text
			LEGEND_TEXTS= G_LEGEND.selectAll(".legend-text").data(DATA, function(d) { return d.label; });

			LEGEND_TEXTS.enter().append("text")
				.classed("legend-text", true)
				.text(function(d) { return d.label; })
			.merge(LEGEND_TEXTS)
				.attr("x", function(d, i) { return LEG_EL_POS[i].x + LEG_RECT_WIDTH + LEG_RECT_PAD; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; });
		}

		// Redraw data dependent elements on data change
		function updateElements() {
			calculateLegendDimensions();

			// Add additional gradients if necessary
			GRADIENTS = DEFS.selectAll(".gradient").data(DATA, function(d) { return d.label; });

			GRADIENTS.enter().append("linearGradient")
				.classed("gradient", true)
				.attr("id", function(d) { return d.label + "-gradient"; })
				.attr("x1", "0%")
				.attr("x2", "100%")
				.attr("y1", "50%")
				.attr("y2", "50%")
				.each(function() {

					d3.select(this).append("stop")
					   .attr('class', 'start')
					   .attr("offset", "0%")
					   .attr("stop-color", function(d) { return FILL[d.label]; })
					   .attr("stop-opacity", 1);

					d3.select(this).append("stop")
					   .attr('class', 'end')
					   .attr("offset", "100%")
					   .attr("stop-color", function(d) { return FILL[d.label]; })
					   .attr("stop-opacity", .7);
			});

			// Update data arcs
			DATA_ARCS = G_CHART_AREA.selectAll(".data-arc").data(DATA, function(d) { return d.label; });

			DATA_ARCS.transition()
		    	.duration(TRANS_TIME)
		    	.attrTween("d", function(d) {
		    		d3.select("#"+d.label).attr("data-d", JSON.stringify(d));

		    		return arcTween(d, d.startAngle, d.finalStartAngle, d.endAngle, d.finalEndAngle);
		    	});

		    DATA_ARCS.enter().append("path")
				.classed("exiting", false)
				.classed("data-arc", true)
				.classed("selectable", true)
				.classed("selected", function(d) { return d.selected; })
				.attr("id", function(d) { return d.label; })
				.attr("data-d", function(d) { return JSON.stringify(d); })
				.attr("fill", function(d) { return "url(#" + (d.label) + "-gradient)"; })
				.attr("stroke-width", 0)
				.attr("stroke", function(d) { return STROKE[d.label]; })
				.attr("d", function(d) {
					var prev = $("#" + d.label).prev();
					var prevD = prev.hasClass("data-arc") ? JSON.parse(prev.attr("data-d")) : {endAngle: 0};

					return PATH({startAngle: prevD.endAngle, endAngle: prevD.endAngle});
				})
				.on("click", function(d, i) { selectElement(d, i, this); })
				// .on("mouseover", TIP.show)
				// .on("mouseout", TIP.hide)
			.transition().duration(TRANS_TIME)
				.attr("stroke-width", 1)
		    	.attrTween("d", function(d) {
		    		var prev = $("#" + d.label).prev();
					var prevD = prev.hasClass("data-arc") ? JSON.parse(prev.attr("data-d")) : {endAngle: 0};

		    		return arcTween(d, prevD.endAngle, d.finalStartAngle, prevD.endAngle, d.finalEndAngle);
		    	});

		    DATA_ARCS.exit()
		    	.classed("exiting", true)
		    .transition().duration(TRANS_TIME)
				.attr("stroke-width", 0)
		    	.attrTween("d", function(d, i) {
		    		var prev = $("#" + d.label).prev();
					while (prev.hasClass("exiting")) {
						prev = prev.prev();
					}
					var prevD = prev.hasClass("data-arc") ? JSON.parse(prev.attr("data-d")) : {finalEndAngle: 0};

		    		return arcTween(d, d.startAngle, prevD.finalEndAngle, d.endAngle, prevD.finalEndAngle);
		    	})
		    	.remove();

		    // Update legend rects
			LEGEND_RECTS = G_LEGEND.selectAll(".legend-rect").data(DATA, function(d) { return d.label; });

			LEGEND_RECTS.transition().duration(TRANS_TIME)
				.attr("x", function(d, i) { return LEG_EL_POS[i].x; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; });

			LEGEND_RECTS.enter().append("rect")
				.classed("legend-rect", true)
				.attr("width", LEG_RECT_WIDTH)
				.attr("height", LEG_RECT_WIDTH)
				.attr("fill", function(d) { return "url(#" + (d.label) + "-gradient)"; })
				.attr("stroke-width", "1")
				.attr("stroke", function(d) { return STROKE[d.label]; })
				.attr("x", function(d, i) { return LEG_EL_POS[i].x; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; })
				.style("opacity", 0)
			.transition().duration(TRANS_TIME)
				.style("opacity", 1);

			LEGEND_RECTS.exit().transition().duration(TRANS_TIME)
				.style("opacity", function(d) { return 0; })
				.remove();

		    // Update legend text
			LEGEND_TEXTS = G_LEGEND.selectAll(".legend-text").data(DATA, function(d) { return d.label; });

			LEGEND_TEXTS.transition().duration(TRANS_TIME)
				.attr("x", function(d, i) { return LEG_EL_POS[i].x + LEG_RECT_WIDTH + LEG_RECT_PAD; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; });

			LEGEND_TEXTS.enter("legend-text-enter").append("text")
				.classed("legend-text", true)
				.attr("x", function(d, i) { return LEG_EL_POS[i].x + LEG_RECT_WIDTH + LEG_RECT_PAD; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; })
				.text(function(d) { return d.label; })
				.style("opacity", 0)
			.transition().duration(TRANS_TIME)
				.style("opacity", 1);

			LEGEND_TEXTS.exit().transition().duration(TRANS_TIME)
				.style("opacity", function(d) { return 0; })
				.remove();
		}

		// Deselect all on svg click
		function deselectAllElements() {
			d3.selectAll(".selectable").each(function(d) { d.selected = false; });
			d3.selectAll(".selectable").classed("selected", false);
			va.messagingUtil.postSelectionMessage(VA_RESULT_NAME, []);
		}

		// Handle selection on element
		function selectElement(d, i, el) {
			// Prevent event from falling through to underlying elements
			d3.event.stopPropagation();

			// Bring element to front in case there is overlap with other elements
			d3.select(el).moveToFront();

			// If control is held toggle selected on click preserving array, otherwise select only clicked element
			if (d3.event.ctrlKey) {
				d.selected = !d.selected;
				d3.select(el).classed("selected", d.selected);

				var selections = [];
				d3.selectAll(".selectable").each(function(d, i){
					if (d.selected) {
						selections.push({row: i});
					}
				});

				va.messagingUtil.postSelectionMessage(VA_RESULT_NAME, selections);
			}
			else {
				d3.selectAll(".selectable").each(function(d) { d.selected = false; });
				d3.selectAll(".selectable").classed("selected", false);
				d.selected = true;
				d3.select(el).classed("selected", true);
				va.messagingUtil.postSelectionMessage(VA_RESULT_NAME, [{row: i}]);
			}
		}

		/******************************************************* Helper Functions *******************************************************/
		// Determine whether or not page is being rendered in iFrame
		function inIframe () {
			try {
				return window.self !== window.top;
			} catch (e) {
				return true;
			}
		}

		// Helper function to bring element to front of SVG (from https://github.com/wbkd/d3-extended)
		d3.selection.prototype.moveToFront = function() {
	    	return this.each(function(){
	    		this.parentNode.appendChild(this);
	    	});
		};

		function calculateLegendDimensions() {
			// Get height of legend title to determine vertical offset of legend elements
			LEG_TITLE_HEIGHT = $(".legend-title")[0].getBBox().height;

			// Create dummy text variables to caculate widths for legend text elements
			var textWidths = []
			d3.select("#" + SVG_ID).selectAll('.dummyText').data(DATA).enter().append("text")
				.classed("legend-text", true)
			    .text(function(d) { return d.label})
			    .each(function(d, i) {
			        textWidths.push(this.getComputedTextLength());
			        this.remove();
			    });

			// Determine which row each element will sit in and how long each row is
			var rows = [];
			var rowSums = [];
			var rowSum;
			var row = 0;
			for (var i=0, length=textWidths.length; i<length; i++) {
				rowSum = textWidths[i] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD;
				rows.push(row);
				while(rowSum +  textWidths[i+1] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD<=DRAWABLE_WIDTH && i+1<length) {
					i++;
					rowSum += textWidths[i] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD;
					rows.push(row);
				}
				rowSums.push(rowSum);
				row++;
			}

			// Calculate x and y coordinates for legend elements
			LEG_EL_POS = [];
			for (var i=0, length=textWidths.length; i<length; i++) {
				LEG_EL_POS.push({
					x: (i==0 || rows[i-1]!=rows[i]) ? DRAWABLE_WIDTH/2 - rowSums[rows[i]]/2 : LEG_EL_POS[i-1].x + textWidths[i-1] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD,
					y: rows[i]*LEG_ROW_HEIGHT + LEG_TITLE_TOP_PAD + LEG_TITLE_HEIGHT + LEG_TITLE_BOT_PAD
				});
			}
		}

		function arcTween(d, origStart, finalStart, origEnd, finalEnd) {
				var interpolateStart = d3.interpolate(origStart, finalStart);
				var interpolateEnd = d3.interpolate(origEnd, finalEnd);
				return function(t) {
					d.startAngle = interpolateStart(t);
					d.finalStartAngle = finalStart;
					d.endAngle = interpolateEnd(t);
					d.finalEndAngle = finalEnd;
					d3.select("#" + d.label).attr("data-d", JSON.stringify(d));
					return PATH(d);
				};
			}
	}
</script>
</body>
</html>
