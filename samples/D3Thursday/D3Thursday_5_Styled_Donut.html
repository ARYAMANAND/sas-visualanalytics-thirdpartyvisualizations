<!DOCTYPE html>
<!--
Copyright 2018 SAS Institute Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
<head>
	<!-- Import D3.js -->
	<script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>

	<!-- Import d3-tip -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.9.1/d3-tip.min.js"></script>

	<!-- Import utilities  -->
	<script type="text/javascript" src="../../util/messagingUtil.js"></script>
	<script type="text/javascript" src="../../util/contentUtil.js"></script>
</head>
<body>
<style type="text/css">
	html, body, svg {
		overflow: hidden;
		margin: 0px;
		width: 100%;
		height: 100%;
	}

	text {
		font-family: Verdana, sans-serif;
	}

	.data-arc.selected {
		stroke-width: 2px;
		stroke: black;
	}

	.legend-title {
		font-size: 1.0em;
		text-anchor: middle;
		alignment-baseline: hanging;
	}

	.legend-text {
		font-size: .8em;
		alignment-baseline: hanging;
	}

	.d3-tip {
		background: white;
		position: relative;
    	border: 1px solid #C4C4C4;
		border-radius: 4px;
	}

	.d3-tip:before {
		content: "";
		position: absolute;
		top: 100%;
		left: 50%;
		height: 10px;
		width: 10px;
		background: white;
		box-sizing:border-box;
		transform: rotate(45deg) translate(-50%);
		border-bottom: inherit;
		border-right: inherit;
		box-shadow: inherit;
	}

	.d3-tip-content {
		font-size: .8em;
		text-align: left;
	}
</style>

<script>
	"use strict";

	document.addEventListener("DOMContentLoaded", function(e) {
		/*************************************************** Declare global variables ***************************************************/
		// Data variables
		var SVG_ID = "styled-donut";														// ID of SVG element
		var SAMPLE_MESSAGE = {
		    "version": "1",
		    "resultName": "dd75",
		    "rowCount": 6,
		    "availableRowCount": 6,
		    "data": [
		        [
		            "Hybrid",
		            3
		        ],
		        [
		            "Sedan",
		            262
		        ],
		        [
		            "Sports",
		            49
		        ],
		        [
		            "SUV",
		            60
		        ],
		        [
		            "Truck",
		            24
		        ],
		        [
		            "Wagon",
		            30
		        ]
		    ],
		    "columns": [
		        {
		            "name": "bi77",
		            "label": "Type",
		            "type": "string"
		        },
		        {
		            "name": "bi78",
		            "label": "Frequency",
		            "type": "number",
		            "usage": "quantitative",
		            "aggregation": "totalCount",
		            "format": {
		                "name": "COMMA",
		                "width": 12,
		                "precision": 0,
		                "formatString": "COMMA12."
		            }
		        }
		    ]
		};																					// Sample data message to render graph outside of VA for debugging
		var VA_MESSAGE;																		// Data message to be received from VA
		var VA_RESULT_NAME;																	// Result name required to send messages back to VA
		var SELECTED = [];																	// Selected rows passed in from VA
		var DATA = [];																		// Data to be parsed from VA data message
		var METADATA = [];																	// Metadata to be parsed from VA data message
		var FILL = {
			"Hybrid": "#21b9b7",
			"Sedan": "#4141e0",
			"Sports":  "#7db71a",
			"SUV": "#8e2f8a",
			"Truck": "#d38506",
			"Wagon": "#0abf85"
		};																					// Fill colors keyed to labels
		var STROKE = {
			"Hybrid": "#1d9992",
			"Sedan": "#2222bc",
			"Sports": "#6a9617",
			"SUV": "#6d256d",
			"Truck": "#ba7006",
			"Wagon": "#0a9e69"
		};																					// Stroke colors keyed to labels

		// Static dimension variables
		var MARGIN = {top: 70, right: 10, bottom: 10, left: 10};							// Margin on interior edge of SVG
		var TRANS_TIME = 500;																// Duration of transitions
		var LEG_MIN_HEIGHT = 50;															// Minimum height allocated for legend
		var LEG_ROW_HEIGHT = 15;															// Height allocated for each row of legend
		var LEG_RECT_WIDTH = 12;															// Width of legend rects
		var LEG_TITLE_TOP_PAD = 5;															// Padding between chart and legend title
		var LEG_TITLE_HEIGHT;																// Height of legend title element
		var LEG_TITLE_BOT_PAD = 5;															// Padding between legend title bottom and
		var LEG_RECT_PAD = 5;																// Padding between legend rect and legend text
		var LEG_TEXT_PAD = 5;																// Padding after legend text

		// Dynamic dimension variables
		var WIDTH = window.innerWidth;														// Width of SVG element
		var HEIGHT = window.innerHeight;													// Height of SVG element
		var DRAWABLE_WIDTH = WIDTH - MARGIN.right - MARGIN.left;							// Drawable width of SVG
		var DRAWABLE_HEIGHT = HEIGHT - MARGIN.bottom - MARGIN.top;							// Drawable height of SVG
		var ARC_PADDING;																	// Padding in radians between arc segments
		var RADIUS = Math.min(DRAWABLE_WIDTH, DRAWABLE_HEIGHT-LEG_MIN_HEIGHT) / 2;			// Radius of pie/donut
		var LEG_HEIGHT = Math.max(LEG_MIN_HEIGHT, DRAWABLE_HEIGHT-2*RADIUS);				// Height allocated for legend
		var LEG_EL_POS = [];																// Positions of legend text elements

		// Selection and d3 variables
		var SVG;																			// SVG selection
		var TIP;																			// Tooltip generator
		var DEFS;																			// Defs element selection
		var G_CHART_AREA;																	// Chart Area Group selection
		var G_LEGEND;																		// Legend Group selection
		var PATH;																			// Path generator to create arc paths from arc data
		var GRADIENTS;																		// Gradients data-join
		var TOOL_TIPS;																		// Tool tips data-join
		var DATA_ARCS;																		// Data Arcs data-join
		var LEGEND_TITLE;																	// Legend title data-join
		var LEGEND_RECTS;																	// Legend rects data-join
		var LEGEND_TEXTS;																	// Legend texts data-join

		// Attach event for data message from VA
		va.messagingUtil.setOnDataReceivedCallback(onDataReceived);

		// If not being rendered in iFrame (outside VA), render with sample data
		if (!inIframe()) { onDataReceived(SAMPLE_MESSAGE); }

		// Listen for resize event
		va.contentUtil.setupResizeListener(drawElements);

		// Take action on received data
		function onDataReceived(messageFromVA) {
			// Initialize global data variables
			VA_MESSAGE = messageFromVA;
			VA_RESULT_NAME = messageFromVA.resultName;
			SELECTED = va.contentUtil.initializeSelections(messageFromVA);

			// Validate data roles
			if (!va.contentUtil.validateRoles(messageFromVA, ["string", "number"], null)) {
				va.messagingUtil.postInstructionalMessage(VA_RESULT_NAME,
					"D3 Donut Chart expects columns to be assigned in this order:\n" +
					" 1. Category (string)\n" +
					" 2. Measure (number)");
				return;
			}

			// Parse metadata from data message
			METADATA = {
				category: VA_MESSAGE.columns[0].label,
				measure: VA_MESSAGE.columns[1].label
			};

			// Parse data from 2d array to array of objects
			var total = d3.sum(VA_MESSAGE.data, function(d) { return d[1]; });
			var label, measure, currentData, finalStartAngle, finalEndAngle, startAngle, endAngle;
			DATA = [];
			for (var i=0, length=VA_MESSAGE.data.length; i<length; i++) {
				label = VA_MESSAGE.data[i][0];
			 	measure = VA_MESSAGE.data[i][1];

				currentData = d3.select("#" + label);

				finalStartAngle =  i==0 ? 0 : DATA[i-1].finalEndAngle;
				finalEndAngle = i==0 ? ((measure/total)*2*Math.PI) : (DATA[i-1].finalEndAngle + (measure/total)*2*Math.PI);

				startAngle = currentData.empty() ? finalStartAngle : JSON.parse(currentData.attr("data-d")).startAngle;
				endAngle =  currentData.empty() ? finalEndAngle : JSON.parse(currentData.attr("data-d")).endAngle;

				DATA.push({
					label: label,
					measure: measure,
					finalStartAngle: finalStartAngle,
					finalEndAngle: finalEndAngle,
					startAngle: startAngle,
					endAngle: endAngle
				});
			}

			// Initialize chart if first draw, otherwise process data and update elements accordingly
			if (d3.select("#" + SVG_ID).empty()) {
				ARC_PADDING = Math.min((d3.min(VA_MESSAGE.data, function(d) { return d[1]; })/(4*total))*2*Math.PI, .03);
				drawElements();
			}
			else {
				updateElements();
			}

			// Apply selections
			d3.selectAll(".selectable")
				.classed("selected", false)
				.filter(function(d, i) {
					return SELECTED.find(function(selection) {
						 return selection.row == i;
					 });
				})
				.classed("selected", true);
		}

		// Draw elements for first time and on resize event
		function drawElements() {
			// Calculate dimensions for graph based on container dimensions
			WIDTH = window.innerWidth;
			HEIGHT = window.innerHeight;
			DRAWABLE_WIDTH = WIDTH - MARGIN.right - MARGIN.left;
			DRAWABLE_HEIGHT = HEIGHT - MARGIN.bottom - MARGIN.top;
			RADIUS = Math.min(DRAWABLE_WIDTH, DRAWABLE_HEIGHT - LEG_MIN_HEIGHT) / 2;
			LEG_HEIGHT = Math.max(LEG_MIN_HEIGHT, DRAWABLE_HEIGHT-2*RADIUS);

			// Append svg and save reference
			d3.select("body").selectAll("#" + SVG_ID).data([DATA]).enter().append("svg")
				.attr("id", SVG_ID)
				.on("click", deselectAllElements);

			SVG = d3.select("#" + SVG_ID)
				.attr("width", WIDTH)
				.attr("height", HEIGHT);

			// Initialize tooltip
			TIP = d3.tip()
		    	.attr("class", "d3-tip")
		    	.offset([-8, 0])
		    	.html(function(d) {
					return "<table class='d3-tip-content'> <tr> <th> " + METADATA.category + "</th> <td>" + d.label + "</td> </tr>" +
						   "<tr> <th> " + METADATA.measure + "</th> <td>" + d.measure + "</td> </tr> </table>";
				});
		    SVG.call(TIP);

			// Append defs and save reference
			SVG.selectAll(".gradient-defs").data([DATA]).enter().append("defs")
				.classed("gradient-defs", true);

			DEFS = SVG.select(".gradient-defs");

			// Append/update chart-area group and save reference
			SVG.selectAll(".g-chart-area").data([DATA]).enter().append("g")
				.classed("g-chart-area", true);

			G_CHART_AREA = SVG.select(".g-chart-area")
				.attr("transform", "translate(" + (WIDTH/2) + "," + (MARGIN.top + (DRAWABLE_HEIGHT-LEG_HEIGHT)/2) + ")");

			// Append/update legend group and save reference
			SVG.selectAll(".g-legend").data([DATA]).enter().append("g")
				.classed("g-legend", true);

			G_LEGEND = SVG.select(".g-legend")
				.attr("transform", "translate(" + (MARGIN.left) + "," + (HEIGHT-MARGIN.bottom-LEG_HEIGHT) + ")");

			// Create path generator
			PATH = d3.arc().outerRadius(RADIUS).innerRadius(.7*RADIUS);

			// Create gradients
			GRADIENTS = DEFS.selectAll(".gradient").data(DATA, function(d) { return d.label; });

			GRADIENTS.enter().append("linearGradient")
				.classed("gradient", true)
				.attr("id", function(d) { return d.label + "-gradient"; })
				.attr("x1", "0%")
				.attr("x2", "100%")
				.attr("y1", "50%")
				.attr("y2", "50%")
				.each(function() {

					d3.select(this).append("stop")
					   .attr('class', 'start')
					   .attr("offset", "0%")
					   .attr("stop-color", function(d) { return FILL[d.label]; })
					   .attr("stop-opacity", 1);

					d3.select(this).append("stop")
					   .attr('class', 'end')
					   .attr("offset", "100%")
					   .attr("stop-color", function(d) { return FILL[d.label]; })
					   .attr("stop-opacity", .7);
			});

			// Create data arcs
			DATA_ARCS = G_CHART_AREA.selectAll(".data-arc").data(DATA);

			DATA_ARCS.enter().append("path")
		    	.classed("exiting", false)
				.classed("data-arc", true)
				.classed("selectable", true)
				.attr("id", function(d) { return d.label; })
				.attr("data-d", function(d) { return JSON.stringify(d); })
				.attr("fill", function(d) { return "url(#" + (d.label) + "-gradient)"; })
				.attr("stroke-width", 1)
				.attr("stroke", function(d) { return STROKE[d.label]; })
				.on("click", function(d, i) { selectElement(d, i, this); })
		    	.on("mouseover", TIP.show)
		    	.on("mouseout", TIP.hide)
			.merge(DATA_ARCS)
				.attr("d", function(d) {
					console.log(d.finalStartAngle);
					console.log(ARC_PADDING);
					console.log(d.finalStartAngle + ARC_PADDING);
					return PATH({startAngle: d.finalStartAngle + ARC_PADDING, endAngle: d.finalEndAngle - ARC_PADDING});
				});

			// Create legend title
			LEGEND_TITLE = G_LEGEND.selectAll(".legend-title").data([DATA]);

			LEGEND_TITLE.enter().append("text")
				.classed("legend-title", true)
				.text(METADATA.category)
			.merge(LEGEND_TITLE)
				.attr("x", function(d, i) { return DRAWABLE_WIDTH/2 })
				.attr("y", function(d, i) { return LEG_TITLE_TOP_PAD; });

			// Compute the x y locations for legend elements
			calculateLegendDimensions();

			// Create legend rects
			LEGEND_RECTS = G_LEGEND.selectAll(".legend-rect").data(DATA, function(d) { return d.label; });

			LEGEND_RECTS.enter().append("rect")
				.classed("legend-rect", true)
				.attr("width", LEG_RECT_WIDTH)
				.attr("height", LEG_RECT_WIDTH)
				.attr("fill", function(d) { return "url(#" + (d.label) + "-gradient)"; })
				.attr("stroke-width", 1)
				.attr("stroke", function(d) { return STROKE[d.label]; })
			.merge(LEGEND_RECTS)
				.attr("x", function(d, i) { return LEG_EL_POS[i].x; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; });

			// Create legend text
			LEGEND_TEXTS= G_LEGEND.selectAll(".legend-text").data(DATA, function(d) { return d.label; });

			LEGEND_TEXTS.enter().append("text")
				.classed("legend-text", true)
				.text(function(d) { return d.label; })
			.merge(LEGEND_TEXTS)
				.attr("x", function(d, i) { return LEG_EL_POS[i].x + LEG_RECT_WIDTH + LEG_RECT_PAD; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; });
		}

		// Redraw data dependent elements on data change
		function updateElements() {
			calculateLegendDimensions();

			// Add additional gradients if necessary
			GRADIENTS = DEFS.selectAll(".gradient").data(DATA, function(d) { return d.label; });

			GRADIENTS.enter().append("linearGradient")
				.classed("gradient", true)
				.attr("id", function(d) { return d.label + "-gradient"; })
				.attr("x1", "0%")
				.attr("x2", "100%")
				.attr("y1", "50%")
				.attr("y2", "50%")
				.each(function() {

					d3.select(this).append("stop")
					   .attr('class', 'start')
					   .attr("offset", "0%")
					   .attr("stop-color", function(d) { return FILL[d.label]; })
					   .attr("stop-opacity", 1);

					d3.select(this).append("stop")
					   .attr('class', 'end')
					   .attr("offset", "100%")
					   .attr("stop-color", function(d) { return FILL[d.label]; })
					   .attr("stop-opacity", .7);
			});

			// Update data arcs
			DATA_ARCS = G_CHART_AREA.selectAll(".data-arc").data(DATA, function(d) { return d.label; });

			DATA_ARCS.transition()
		    	.duration(TRANS_TIME)
		    	.attrTween("d", function(d) {
		    		d3.select("#"+d.label).attr("data-d", JSON.stringify(d));

		    		return arcTween(d, d.startAngle, d.finalStartAngle + ARC_PADDING, d.endAngle, d.finalEndAngle - ARC_PADDING);
		    	});

		    DATA_ARCS.enter().append("path")
				.classed("exiting", false)
				.classed("data-arc", true)
				.classed("selectable", true)
				.attr("id", function(d) { return d.label; })
				.attr("data-d", function(d) { return JSON.stringify(d); })
				.attr("fill", function(d) { return "url(#" + (d.label) + "-gradient)"; })
				.attr("stroke-width", 0)
				.attr("stroke", function(d) { return STROKE[d.label]; })
				.attr("d", function(d) {
					var prev = d3.select(this.previousElementSibling);
					var prevD = prev.node() ? JSON.parse(prev.attr("data-d")) : {endAngle: 0};

					return PATH({startAngle: prevD.endAngle + ARC_PADDING, endAngle: prevD.endAngle - ARC_PADDING});
				})
				.on("click", function(d, i) { selectElement(d, i, this); })
		    	.on("mouseover", TIP.show)
		    	.on("mouseout", TIP.hide)
			.transition().duration(TRANS_TIME)
				.attr("stroke-width", 1)
		    	.attrTween("d", function(d) {
					var prev = d3.select(this.previousElementSibling);
					var prevD = prev.node() ? JSON.parse(prev.attr("data-d")) : {endAngle: 0};

		    		return arcTween(d, prevD.endAngle, d.finalStartAngle + ARC_PADDING, prevD.endAngle, d.finalEndAngle - ARC_PADDING);
		    	});

		    DATA_ARCS.exit()
		    	.classed("exiting", true)
		    .transition().duration(TRANS_TIME)
				.attr("stroke-width", 0)
		    	.attrTween("d", function(d, i) {
					var prev = d3.select(this.previousElementSibling);
					while (prev.node() && prev.classed("exiting")) {
						prev = d3.select(prev.node().previousElementSibling);
					}
					var prevD = prev.node() ? JSON.parse(prev.attr("data-d")) : {finalEndAngle: 0};

		    		return arcTween(d, d.startAngle, prevD.finalEndAngle + ARC_PADDING, d.endAngle, prevD.finalEndAngle - ARC_PADDING);
		    	})
		    	.remove();

		    // Update legend rects
			LEGEND_RECTS = G_LEGEND.selectAll(".legend-rect").data(DATA, function(d) { return d.label; });

			LEGEND_RECTS.transition().duration(TRANS_TIME)
				.attr("x", function(d, i) { return LEG_EL_POS[i].x; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; });

			LEGEND_RECTS.enter().append("rect")
				.classed("legend-rect", true)
				.attr("width", LEG_RECT_WIDTH)
				.attr("height", LEG_RECT_WIDTH)
				.attr("fill", function(d) { return "url(#" + (d.label) + "-gradient)"; })
				.attr("stroke-width", "1")
				.attr("stroke", function(d) { return STROKE[d.label]; })
				.attr("x", function(d, i) { return LEG_EL_POS[i].x; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; })
				.style("opacity", 0)
			.transition().duration(TRANS_TIME)
				.style("opacity", 1);

			LEGEND_RECTS.exit().transition().duration(TRANS_TIME)
				.style("opacity", function(d) { return 0; })
				.remove();

		    // Update legend text
			LEGEND_TEXTS = G_LEGEND.selectAll(".legend-text").data(DATA, function(d) { return d.label; });

			LEGEND_TEXTS.transition().duration(TRANS_TIME)
				.attr("x", function(d, i) { return LEG_EL_POS[i].x + LEG_RECT_WIDTH + LEG_RECT_PAD; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; });

			LEGEND_TEXTS.enter("legend-text-enter").append("text")
				.classed("legend-text", true)
				.attr("x", function(d, i) { return LEG_EL_POS[i].x + LEG_RECT_WIDTH + LEG_RECT_PAD; })
				.attr("y", function(d, i) { return LEG_EL_POS[i].y; })
				.text(function(d) { return d.label; })
				.style("opacity", 0)
			.transition().duration(TRANS_TIME)
				.style("opacity", 1);

			LEGEND_TEXTS.exit().transition().duration(TRANS_TIME)
				.style("opacity", function(d) { return 0; })
				.remove();
		}

		/******************************************************* Helper Functions *******************************************************/
		// Determine whether or not page is being rendered in iFrame
		function inIframe () {
			try {
				return window.self !== window.top;
			} catch (e) {
				return true;
			}
		}

		// Deselect all on svg click
		function deselectAllElements() {
			// Deselect all elements
			d3.selectAll(".selectable").classed("selected", false);

			// Post message to VA
			va.messagingUtil.postSelectionMessage(VA_RESULT_NAME, []);
		}

		// Handle selection on element
		function selectElement(datum, index, el) {
			// Prevent event from falling through to underlying elements
			d3.event.stopPropagation();

			// If control is held toggle selected on click preserving array, otherwise select only clicked element
			if (d3.event.ctrlKey) {
				// Toggle selection on clicked element
				d3.select(el).classed("selected", !d3.select(el).classed("selected"));

				// Build array of selected elements
				var selections = [];
				d3.selectAll(".selectable").each(function(d, i){
					if (d3.select(this).classed("selected")) {
						selections.push({row: i});
					}
				});

				// Post message to VA
				va.messagingUtil.postSelectionMessage(VA_RESULT_NAME, selections);
			}
			else {
				// Deselect all elements
				d3.selectAll(".selectable").classed("selected", false);

				// Select clicked element
				d3.select(el).classed("selected", true);

				// Post message to VA
				va.messagingUtil.postSelectionMessage(VA_RESULT_NAME, [{row: index}]);
			}
		}

		// Helper function to bring element to front of SVG (from https://github.com/wbkd/d3-extended)
		function calculateLegendDimensions() {
			// Get height of legend title to determine vertical offset of legend elements
			LEG_TITLE_HEIGHT = d3.select(".legend-title").node().getBBox().height;

			// Create dummy text variables to caculate widths for legend text elements
			var textWidths = []
			d3.select("#" + SVG_ID).selectAll('.dummyText').data(DATA).enter().append("text")
				.classed("legend-text", true)
			    .text(function(d) { return d.label})
			    .each(function(d, i) {
			        textWidths.push(this.getComputedTextLength());
			        this.remove();
			    });

			// Determine which row each element will sit in and how long each row is
			var rows = [];
			var rowSums = [];
			var rowSum;
			var row = 0;
			for (var i=0, length=textWidths.length; i<length; i++) {
				rowSum = textWidths[i] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD;
				rows.push(row);
				while(rowSum +  textWidths[i+1] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD<=DRAWABLE_WIDTH && i+1<length) {
					i++;
					rowSum += textWidths[i] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD;
					rows.push(row);
				}
				rowSums.push(rowSum);
				row++;
			}

			// Calculate x and y coordinates for legend elements
			LEG_EL_POS = [];
			for (var i=0, length=textWidths.length; i<length; i++) {
				LEG_EL_POS.push({
					x: (i==0 || rows[i-1]!=rows[i]) ? DRAWABLE_WIDTH/2 - rowSums[rows[i]]/2 : LEG_EL_POS[i-1].x + textWidths[i-1] + LEG_RECT_WIDTH + LEG_RECT_PAD + LEG_TEXT_PAD,
					y: rows[i]*LEG_ROW_HEIGHT + LEG_TITLE_TOP_PAD + LEG_TITLE_HEIGHT + LEG_TITLE_BOT_PAD
				});
			}
		}

		// Tween function to create interpolators for arc segments
		function arcTween(d, origStart, finalStart, origEnd, finalEnd) {
			var interpolateStart = d3.interpolate(origStart, finalStart);
			var interpolateEnd = d3.interpolate(origEnd, finalEnd);
			return function(t) {
				d.startAngle = interpolateStart(t);
				d.finalStartAngle = finalStart;
				d.endAngle = interpolateEnd(t);
				d.finalEndAngle = finalEnd;
				d3.select("#" + d.label).attr("data-d", JSON.stringify(d));
				return PATH(d);
			};
		}
	});
</script>
</body>
</html>
