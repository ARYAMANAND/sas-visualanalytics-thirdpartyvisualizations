<!DOCTYPE html>
<!--
Copyright 2018 SAS Institute Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
<head>
  <!-- Import D3.js -->
  <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>

  <!-- Import three.js (minified) and post processing files -->
  <script type="text/javascript" src="https://threejs.org/build/three.min.js"></script>
  <script type="text/javascript" src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>
  <script type="text/javascript" src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
  <script type="text/javascript" src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
  <script type="text/javascript" src="https://threejs.org/examples/js/postprocessing/OutlinePass.js"></script>
  <script type="text/javascript" src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>

  <!-- Import WebGL.js (detect three.js compatibility with browser) -->
  <script type="text/javascript" src="https://threejs.org/examples/js/WebGL.js"></script>

  <!-- Import TrackballControls.js (add controls to move camera around scene) -->
  <script type="text/javascript" src="https://threejs.org/examples/js/controls/TrackballControls.js"></script>

  <!-- Import utilities  -->
  <script type="text/javascript" src="../../util/messagingUtil.js"></script>
  <script type="text/javascript" src="../../util/contentUtil.js"></script>
</head>
<body>
<style type="text/css">
  html, body {
    overflow: hidden;
    margin: 0px;
    width: 100%;
    height: 100%;
  }

  canvas {
    position: absolute;
  }

  p {
    margin-top: 5px;
    margin-bottom: 5px;
  }

  .container {
    position: relative;
  }

  .control-reset {
    position: absolute;
    top: 10px;
    right: 10px;
  }

  .axis-text {
    position: absolute;
    pointer-events: none;
    font-family: Verdana, sans-serif;
    font-size: .8em;
  }

  .tooltip-container {
    position: absolute;
    left: 5px;
  }

  .tooltip-value {
    font-family: Verdana, sans-serif;
    font-size: 1.2em;
  }
</style>

<script>
"use strict;";

document.addEventListener("DOMContentLoaded", function() {
  /******************************************************* Declare variables *******************************************************/

  // Static data variables
  const SAMPLE_MESSAGE = {
    version: "1",
    resultName: "dd81",
    rowCount: 65,
    availableRowCount: 65,
    data: [
      [12, 1000, 5.663329208269168, "."],
      [12, 3000, 14.989566917585456, "."],
      [12, 5000, 20.500298723311772, "."],
      [12, 7000, 22.195524625448137, "."],
      [12, 8000, 21.612322862670034, "."],
      [0.5, 1000, 55.60790437171834, "."],
      [0.5, 3000, 32.77512032745825, "."],
      [0.5, 5000, 6.126830379608192, "."],
      [0.5, 7000, -24.33696547183184, "."],
      [0.5, 8000, -40.99967811139811, "."],
      [1.5, 1000, 52.77212599052634, "."],
      [1.5, 3000, 32.73577862049027, "."],
      [1.5, 5000, 8.88392534686425, "."],
      [1.5, 7000, -18.783433830351747, "."],
      [1.5, 8000, -34.047928132806, "."],
      [2.5, 1000, 49.64925653223717, "."],
      [2.5, 3000, 32.40934583642514, "."],
      [2.5, 5000, 11.35392923702315, "."],
      [2.5, 7000, -13.516993265968813, "."],
      [2.5, 8000, -27.38326923131105, "."],
      [3.5, 1000, 66, 19.760704003149165],
      [3.5, 3000, 31.795821975262843, "."],
      [3.5, 5000, 13.536842050084886, "."],
      [3.5, 7000, -8.537643778683044, "."],
      [3.5, 8000, -21.005701406913264, "."],
      [4.5, 1000, 42.54224438436735, "."],
      [4.5, 3000, 31.889705882352942, 0.9944988453495505],
      [4.5, 5000, 15.432663786049462, "."],
      [4.5, 7000, -3.8453853684944383, "."],
      [4.5, 8000, -14.915224659612639, "."],
      [5.5, 1000, 38.5581016947867, "."],
      [5.5, 3000, 26.857142857142858, -2.8503581645039127],
      [5.5, 5000, 17.041394444916875, "."],
      [5.5, 7000, 0.5597819645970148, "."],
      [5.5, 8000, -9.11183898940918, "."],
      [6.5, 1000, 34.28686792810888, "."],
      [6.5, 3000, 26.42281879194631, -1.809885137246681],
      [6.5, 5000, 22.390243902439025, 4.02720987575189],
      [6.5, 7000, 4.677858220591292, "."],
      [6.5, 8000, -3.5955443963028744, "."],
      [7.5, 1000, 29.72854308433391, "."],
      [7.5, 3000, 26.470815759642047, "."],
      [7.5, 5000, 19.39758253136022, "."],
      [7.5, 7000, 8.50884339948843, "."],
      [7.5, 8000, 1.6336591197062624, "."],
      [8.5, 1000, 24.883127163461776, "."],
      [8.5, 3000, 24.06896551724138, -0.3528709957525642],
      [8.5, 5000, 21.017857142857142, 0.8728171839209864],
      [8.5, 7000, 14.5, 2.4472624987116127],
      [8.5, 8000, 6.575771558618239, "."],
      [9.5, 1000, 19.750620165492485, "."],
      [9.5, 3000, 22.085766189248687, "."],
      [9.5, 5000, 20.605406309414924, "."],
      [9.5, 7000, 15.309540525991189, "."],
      [9.5, 8000, 11.230792920433082, "."],
      [10.5, 1000, 14.33102209042603, "."],
      [10.5, 3000, 20, 0.5373952115937399],
      [10.5, 5000, 20.778681582796544, "."],
      [10.5, 7000, 13, -5.279252473596841],
      [10.5, 8000, 15.59872320515075, "."],
      [11.5, 1000, 8.624332938262416, "."],
      [11.5, 3000, 16.552352310466684, "."],
      [11.5, 5000, 20.664865779080994, "."],
      [11.5, 7000, 20.961873344105324, "."],
      [11.5, 8000, 19.679562412771244, "."]
    ],
    "columns": [
        {
            "name": "bi78",
            "label": "Cylinders",
            "type": "number",
            "usage": "categorical",
            "format": {
                "name": "BEST",
                "width": 12,
                "precision": 0,
                "formatString": "BEST12."
            }
        },
        {
            "name": "bi79",
            "label": "Weight",
            "type": "number",
            "usage": "categorical",
            "format": {
                "name": "BEST",
                "width": 12,
                "precision": 0,
                "formatString": "BEST12."
            }
        },
        {
            "name": "bi82",
            "label": "MPG Highway",
            "type": "number",
            "usage": "quantitative",
            "aggregation": "sum",
            "format": {
                "name": "F",
                "width": 12,
                "precision": 2,
                "formatString": "F12.2"
            }
        },
        {
            "name": "bi83",
            "label": "Residual",
            "type": "number",
            "usage": "quantitative",
            "aggregation": "sum",
            "format": {
                "name": "F",
                "width": 12,
                "precision": 2,
                "formatString": "F12.2"
            }
        }
    ]
  }; // Sample data message to render graph outside of VA for debugging

  // Dynamic data variables
  let VA_MESSAGE; // Data message to be received from VA
  let VA_RESULT_NAME; // Result name required to send messages back to VA
  let DATA; // Data to be parsed from VA data message
  let COV1; // Array of covariate 1 values
  let COV2; // Array of covariate 2 values
  let COV1_TICKS; // Array of ticks for covariate 1 axis
  let COV2_TICKS; // Array of ticks for covariate 2 axis
  let RESULT_TICKS; // Array of ticks for result axis
  let METADATA; // Metadata to be parsed from VA data message

  // Static dimension variables
  const SPHERE_RADIUS = 0.01; // Radius used for data point spheres
  const SEGMENTS = 32; // Number of horizontal and vertical segments used to construct sphere

  // Dynamic dimension variables
  let WIDTH; // Width of canvas element
  let HEIGHT; // Height of canvas element

  // Selection and d3 variables
  let COV1_SCALE; // Scale covariate 1 (X) to world dimensions
  let COV2_SCALE; // Scale covariate 2 (Z) to world dimensions
  let RESULT_SCALE; // Scale predicted/actual result (Y) to world dimensions
  let COLOR_SCALE; // Linear color scale indicating distance of observation from prediction

  // Three variables
  let AXIS_MATERIAL = new THREE.LineBasicMaterial({ color: "#000000" }); // Material for axis lines
  let GRID_MATERIAL = new THREE.LineBasicMaterial({ color: "#a1a1a1" }); // Material for grid lines
  let PREDICTION_MATERIAL = new THREE.MeshPhongMaterial({
    color: "#bbbbbb",
    side: THREE.DoubleSide
  }); // Material for prediction surface
  let SPHERE_GEOMETRY = new THREE.SphereBufferGeometry(
    SPHERE_RADIUS,
    SEGMENTS,
    SEGMENTS
  ); // Sphere buffer geometry to create data points
  let SCENE; // Webgl scene
  let CAMERA; // Webgl camera
  let RENDERER; // Webgl renderer
  let SPHERES; // Array of sphere meshes representing data points
  let GEOMETRIES; // Array of geometry meshes representing prediction surface
  let MOUSE = new THREE.Vector2(-1, -1); // 2D vector to store normalized mouse coordinates
  let RAYCASTER = new THREE.Raycaster(); // First raycaster for interacting with residual points
  let TEXT_RAYCASTER = new THREE.Raycaster(); // Second raycaster for hiding axis text when behind surface
  let CONTROLS; // Trackball controls object
  let COMPOSER; // Scene composer for post processing
  let RENDER_PASS; // Initial pass to render frame
  let OUTLINE_PASS; // Secondary pass to process highlighting

  /*************************************************** Setup Callback Functions ***************************************************/

  // Display tooltip if sphere is clicked
  window.addEventListener("click", function(event) {
    // Look for intersection with spheres
    MOUSE.x = (event.clientX / WIDTH) * 2 - 1;
    MOUSE.y = -(event.clientY / HEIGHT) * 2 + 1;
    RAYCASTER.setFromCamera(MOUSE, CAMERA);
    const intersects = RAYCASTER.intersectObjects(SPHERES);
    if (intersects.length) {
      let d = intersects[0].object.data;

      // Set outline
      OUTLINE_PASS.selectedObjects = [intersects[0].object];

      // Set tooltip values
      d3.select(".cov1").html(
        METADATA.cov1 + ": " + METADATA.cov1Format(d.cov1)
      );

      d3.select(".cov2").html(
        METADATA.cov2 + ": " + METADATA.cov2Format(d.cov2)
      );

      d3.select(".pred").html(
        METADATA.pred + ": " + METADATA.predFormat(d.pred)
      );

      d3.select(".resid").html(
        METADATA.resid + ": " + METADATA.residFormat(d.resid)
      );
    } else {
      // Clear outline
      OUTLINE_PASS.selectedObjects = [];

      // Clear tooltip values
      d3.selectAll(".tooltip-value").html("");
    }
  });

  // Expose event handler for control reset
  window.controlReset = function() {
    CONTROLS.reset();
  };

  // Attach event for data message from VA
  va.messagingUtil.setOnDataReceivedCallback(onDataReceived);

  // If not being rendered in iFrame (outside VA), render with sample data
  if (!inIframe()) {
    onDataReceived(SAMPLE_MESSAGE);
  }

  // Listen for resize event
  va.contentUtil.setupResizeListener(resize);

  /****************************************************** Callback Functions ******************************************************/

  // Take action on received data
  function onDataReceived(messageFromVA) {
    // Initialize data variables
    VA_MESSAGE = messageFromVA;
    VA_RESULT_NAME = messageFromVA.resultName;

    // Validate data roles
    if (
      !va.contentUtil.validateRoles(
        messageFromVA,
        ["number", "number", "number", "number"],
        ["number"]
      )
    ) {
      va.messagingUtil.postInstructionalMessage(
        VA_RESULT_NAME,
        "D3 3D Residual Plot expects columns to be assigned in this order:\n" +
          " 1. Covariate 1 (X) (number)\n" +
          " 2. Covariate 2 (Z) (number)\n" +
          " 3. Predicted (Y) (number)\n" +
          " 4. Residual (Y) (number)"
      );
      return;
    }

    // Restructure metadata from data message
    METADATA = {
      cov1: VA_MESSAGE.columns[0].label,
      cov1Format: translateFormat(VA_MESSAGE.columns[0].format.formatString),
      cov2: VA_MESSAGE.columns[1].label,
      cov2Format: translateFormat(VA_MESSAGE.columns[1].format.formatString),
      pred: VA_MESSAGE.columns[2].label,
      predFormat: translateFormat(VA_MESSAGE.columns[2].format.formatString),
      resid: VA_MESSAGE.columns[3].label,
      residFormat: translateFormat(VA_MESSAGE.columns[3].format.formatString)
    };

    // Restructure data from 2d array to array of objects
    DATA = [];
    for (let i = 0; i < VA_MESSAGE.data.length; i++) {
      DATA.push({
        cov1: VA_MESSAGE.data[i][0],
        cov2: VA_MESSAGE.data[i][1],
        pred: VA_MESSAGE.data[i][2],
        resid: VA_MESSAGE.data[i][3] != "." ? VA_MESSAGE.data[i][3] : undefined,
        actual:
          VA_MESSAGE.data[i][3] == "."
            ? VA_MESSAGE.data[i][2]
            : VA_MESSAGE.data[i][2] + VA_MESSAGE.data[i][3]
      });
    }

    DATA.sort(function(a, b) {
      return a.cov1 - b.cov1;
    }).sort(function(a, b) {
      return a.cov2 - b.cov2;
    });

    // Extract covariate values into arrays
    COV1 = d3
      .map(DATA, function(d) {
        return d.cov1;
      })
      .keys();

    COV1.map(function(d, i) {
      COV1[i] = parseFloat(d);
    });

    COV2 = d3
      .map(DATA, function(d) {
        return d.cov2;
      })
      .keys();

    COV2.map(function(d, i) {
      COV2[i] = parseFloat(d);
    });

    // Create world scales using min/max values from data
    COV1_SCALE = d3
      .scaleLinear()
      .domain([
        d3.min(DATA, function(d) {
          return d.cov1;
        }),
        d3.max(DATA, function(d) {
          return d.cov1;
        })
      ])
      .range([-0.5, 0.5]);

    COV2_SCALE = d3
      .scaleLinear()
      .domain([
        d3.min(DATA, function(d) {
          return d.cov2;
        }),
        d3.max(DATA, function(d) {
          return d.cov2;
        })
      ])
      .range([-0.5, 0.5]);

    RESULT_SCALE = d3
      .scaleLinear()
      .domain([
        d3.min(DATA, function(d) {
          return Math.min(d.pred, d.actual);
        }),
        d3.max(DATA, function(d) {
          return Math.max(d.pred, d.actual);
        })
      ])
      .range([-0.5, 0.5]);

    COLOR_SCALE = d3
      .scaleLinear()
      .domain([
        0,
        d3.max(DATA, function(d) {
          return Math.abs(d.actual - d.pred);
        })
      ])
      .range(["#bbbbbb", "#ff0000"]);

    // Generate ticks for axes
    COV1_TICKS = getTickValues(
      COV1_SCALE.domain()[0],
      COV1_SCALE.domain()[1],
      10,
      0.01
    );
    COV2_TICKS = getTickValues(
      COV2_SCALE.domain()[0],
      COV2_SCALE.domain()[1],
      10,
      0.01
    );
    RESULT_TICKS = getTickValues(
      RESULT_SCALE.domain()[0],
      RESULT_SCALE.domain()[1],
      10,
      0.01
    );

    // Initialize chart if first draw, otherwise clear canvas and then init
    if (!SCENE) {
      init();
    } else {
      update();
    }
  }

  // Draw elements for first time and on resize event
  function init() {
    // Calculate dimensions for graph based on container dimensions
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;

    // Check if webgl is supported by browser
    if (!THREE.WEBGL.isWebGLAvailable()) {
      document.body.appendChild(THREE.WEBGL.getWebGLErrorMessage());
      return;
    }

    // Init scene
    SCENE = new THREE.Scene();
    SCENE.background = new THREE.Color("#f5f5f5");

    // Init camera and set position
    CAMERA = new THREE.PerspectiveCamera(
      45, // field of view (fov) in degrees
      WIDTH / HEIGHT, // aspect ratio
      0.01, // near field distance
      1000 // far field distance
    );
    CAMERA.position.set(1.5, 0.25, 1.5);

    // Init renderer and set size
    RENDERER = new THREE.WebGLRenderer({
      antialias: true, // turn on antialiasing to smooth jaggies,
      canvas: d3.select("canvas").node()
    });
    RENDERER.setSize(WIDTH, HEIGHT);

    // Add lights
    SCENE.add(new THREE.AmbientLight("#404040"));
    let pointLight = new THREE.PointLight("#ffffff");
    pointLight.position.set(0, 2, 0);
    SCENE.add(pointLight);
    let pointLight2 = new THREE.PointLight("#ffffff");
    pointLight2.position.set(0, -2, 0);
    SCENE.add(pointLight2);

    // Draw axes box
    drawAxesBox();

    // Draw grid lines
    drawGridLines();

    // Create meshes for predicted curve
    let index, geometry, mesh;
    GEOMETRIES = [];
    for (let i = 0; i < COV2.length - 1; i++) {
      for (let j = 0; j < COV1.length - 1; j++) {
        index = i * COV1.length + j;
        for (let k = 0; k < 2; k++) {
          // Create geometry
          geometry = new THREE.Geometry();
          if (k) {
            geometry.vertices.push(
              new THREE.Vector3(
                COV1_SCALE(DATA[index + COV1.length + 1].cov1),
                RESULT_SCALE(DATA[index + COV1.length + 1].pred),
                COV2_SCALE(DATA[index + COV1.length + 1].cov2)
              )
            );
          } else {
            geometry.vertices.push(
              new THREE.Vector3(
                COV1_SCALE(DATA[index].cov1),
                RESULT_SCALE(DATA[index].pred),
                COV2_SCALE(DATA[index].cov2)
              )
            );
          }
          geometry.vertices.push(
            new THREE.Vector3(
              COV1_SCALE(DATA[index + 1].cov1),
              RESULT_SCALE(DATA[index + 1].pred),
              COV2_SCALE(DATA[index + 1].cov2)
            )
          );
          geometry.vertices.push(
            new THREE.Vector3(
              COV1_SCALE(DATA[index + COV1.length].cov1),
              RESULT_SCALE(DATA[index + COV1.length].pred),
              COV2_SCALE(DATA[index + COV1.length].cov2)
            )
          );
          geometry.faces.push(new THREE.Face3(0, 1, 2));
          geometry.computeFaceNormals();

          // Create mesh from custom geometry and add to scene
          mesh = new THREE.Mesh(geometry, PREDICTION_MATERIAL);
          GEOMETRIES.push(mesh);
          SCENE.add(mesh);
        }
      }
    }

    // Create spheres for each residual and append to scene
    let sphere;
    SPHERES = [];
    DATA.forEach(function(d) {
      if (d.resid) {
        // Create new sphere
        sphere = new THREE.Mesh(
          SPHERE_GEOMETRY,
          new THREE.MeshBasicMaterial({
            color: COLOR_SCALE(Math.abs(d.actual - d.pred))
          })
        );

        // Set sphere position
        sphere.position.set(
          COV1_SCALE(d.cov1),
          RESULT_SCALE(d.actual),
          COV2_SCALE(d.cov2)
        );

        // Store data in sphere
        sphere.data = d;

        // Push into array of spheres
        SPHERES.push(sphere);

        // Add to scene
        SCENE.add(sphere);
      }
    });

    // Init camera controls
    CONTROLS = new THREE.TrackballControls(CAMERA, RENDERER.domElement);

    // postprocessing

    COMPOSER = new THREE.EffectComposer(RENDERER);

    RENDER_PASS = new THREE.RenderPass(SCENE, CAMERA);
    COMPOSER.addPass(RENDER_PASS);

    OUTLINE_PASS = new THREE.OutlinePass(
      new THREE.Vector2(WIDTH, HEIGHT),
      SCENE,
      CAMERA
    );
    OUTLINE_PASS.visibleEdgeColor.set("#ff0000");
    OUTLINE_PASS.hiddenEdgeColor.set("#ffffff");
    OUTLINE_PASS.edgeStrength = 10;
    OUTLINE_PASS.edgeGlow = 0;
    OUTLINE_PASS.edgeThickness = 1;
    COMPOSER.addPass(OUTLINE_PASS);

    // Start render loop
    render();

    // Append axes values
    d3.select("body")
      .selectAll(".x-axis-text")
      .data(COV1_TICKS)
      .enter()
      .append("div")
      .classed("axis-text x-axis-text", true)
      .html(function(d) {
        return Math.round(d * 100) / 100;
      })
      .each(function(d) {
        this.position = new THREE.Vector3(COV1_SCALE(d), -0.53, +0.5);
      })
      .each(setXY);

    d3.select("body")
      .selectAll(".z-axis-text")
      .data(COV2_TICKS)
      .enter()
      .append("div")
      .classed("axis-text z-axis-text", true)
      .html(function(d) {
        return Math.round(d * 100) / 100;
      })
      .each(function(d) {
        this.position = new THREE.Vector3(+0.5, -0.53, COV2_SCALE(d));
      })
      .each(setXY);

    d3.select("body")
      .selectAll(".y-axis-text")
      .data(RESULT_TICKS)
      .enter()
      .append("div")
      .classed("axis-text y-axis-text", true)
      .html(function(d) {
        return Math.round(d * 100) / 100;
      })
      .each(function(d) {
        this.position = new THREE.Vector3(-0.54, RESULT_SCALE(d) + 0.03, +0.54);
      })
      .each(setXY);

    // Render loop function
    function render() {
      // Update controls
      CONTROLS.update();

      // Render frame
      requestAnimationFrame(render);
      // RENDERER.render(SCENE, CAMERA);
      COMPOSER.render();

      // Update axis text positions
      d3.selectAll(".axis-text")
        .style("display", setDisplay)
        .each(setXY);
    }
  }

  // Update canvas on new data message
  function update() {
    // Reload page
    document.location.reload(true);
  }

  // Update renderer using new window dimensions
  function resize() {
    // Update dimensions
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;

    // Update camera/renderer
    CAMERA.aspect = WIDTH / HEIGHT;
    CAMERA.updateProjectionMatrix();
    RENDERER.setSize(WIDTH, HEIGHT);
    COMPOSER.setSize(WIDTH, HEIGHT);
  }

  /******************************************************* Helper Functions *******************************************************/

  // Determine whether or not page is being rendered in iFrame
  function inIframe() {
    try {
      return window.self !== window.top;
    } catch (e) {
      return true;
    }
  }

  // Translate SAS format to D3 format
  function translateFormat(formatString) {
    if (formatString.indexOf(".") == formatString.length - 1) formatString += 0;

    if (formatString.includes("DOLLAR"))
      return d3.format(
        formatString.replace("DOLLAR", "$").replace(".", ",.") + "f"
      );
    else if (formatString.includes("COMMA"))
      return d3.format(
        formatString.replace("COMMA", "").replace(".", ",.") + "f"
      );
    else if (formatString.includes("F"))
      return d3.format(formatString.replace("F", "") + "f");
    else if (formatString.includes("BEST"))
      return d3.format(formatString.replace("BEST", "") + "f");
    else if (formatString.includes("PERCENT"))
      return d3.format(
        formatString.replace("PERCENT", "").replace(".", ",.") + "%"
      );
  }

  // Draw axes box in 3d space
  function drawAxesBox() {
    // YZ Plane
    drawLine(
      AXIS_MATERIAL,
      new THREE.Vector3(-0.5, -0.5, -0.5),
      new THREE.Vector3(-0.5, -0.5, +0.5)
    );
    drawLine(
      AXIS_MATERIAL,
      new THREE.Vector3(-0.5, -0.5, +0.5),
      new THREE.Vector3(-0.5, +0.5, +0.5)
    );
    drawLine(
      AXIS_MATERIAL,
      new THREE.Vector3(-0.5, +0.5, +0.5),
      new THREE.Vector3(-0.5, +0.5, -0.5)
    );
    drawLine(
      AXIS_MATERIAL,
      new THREE.Vector3(-0.5, +0.5, -0.5),
      new THREE.Vector3(-0.5, -0.5, -0.5)
    );

    // XY Plane
    drawLine(
      AXIS_MATERIAL,
      new THREE.Vector3(-0.5, -0.5, -0.5),
      new THREE.Vector3(+0.5, -0.5, -0.5)
    );
    drawLine(
      AXIS_MATERIAL,
      new THREE.Vector3(+0.5, -0.5, -0.5),
      new THREE.Vector3(+0.5, +0.5, -0.5)
    );
    drawLine(
      AXIS_MATERIAL,
      new THREE.Vector3(+0.5, +0.5, -0.5),
      new THREE.Vector3(-0.5, +0.5, -0.5)
    );

    // XZ Plane
    drawLine(
      AXIS_MATERIAL,
      new THREE.Vector3(-0.5, -0.5, +0.5),
      new THREE.Vector3(+0.5, -0.5, +0.5)
    );
    drawLine(
      AXIS_MATERIAL,
      new THREE.Vector3(+0.5, -0.5, +0.5),
      new THREE.Vector3(+0.5, -0.5, -0.5)
    );
  }

  // Draw grid lines in 3d space
  function drawGridLines() {
    // Draw result lines in YZ plane
    for (let d, i = 1; i < RESULT_TICKS.length; i++) {
      d = RESULT_TICKS[i];
      drawLine(
        GRID_MATERIAL,
        new THREE.Vector3(-0.5, RESULT_SCALE(d), -0.5),
        new THREE.Vector3(-0.5, RESULT_SCALE(d), +0.5)
      );
    }

    // Draw cov2 lines in YZ Plane
    for (let d, i = 1; i < COV2_TICKS.length; i++) {
      d = COV2_TICKS[i];
      drawLine(
        GRID_MATERIAL,
        new THREE.Vector3(-0.5, -0.5, COV2_SCALE(d)),
        new THREE.Vector3(-0.5, +0.5, COV2_SCALE(d))
      );
    }

    // Draw result lines in XY plane
    for (let d, i = 1; i < RESULT_TICKS.length; i++) {
      d = RESULT_TICKS[i];
      drawLine(
        GRID_MATERIAL,
        new THREE.Vector3(-0.5, RESULT_SCALE(d), -0.5),
        new THREE.Vector3(+0.5, RESULT_SCALE(d), -0.5)
      );
    }

    // Draw cov1 lines in XY plane
    for (let d, i = 1; i < COV1_TICKS.length; i++) {
      d = COV1_TICKS[i];
      drawLine(
        GRID_MATERIAL,
        new THREE.Vector3(COV1_SCALE(d), -0.5, -0.5),
        new THREE.Vector3(COV1_SCALE(d), +0.5, -0.5)
      );
    }

    // Draw cov1 lines in XZ plane
    for (let d, i = 1; i < COV1_TICKS.length; i++) {
      d = COV1_TICKS[i];
      drawLine(
        GRID_MATERIAL,
        new THREE.Vector3(COV1_SCALE(d), -0.5, -0.5),
        new THREE.Vector3(COV1_SCALE(d), -0.5, +0.5)
      );
    }

    // Draw cov2 lines in XZ plane
    for (let d, i = 1; i < COV2_TICKS.length; i++) {
      d = COV2_TICKS[i];
      drawLine(
        GRID_MATERIAL,
        new THREE.Vector3(-0.5, -0.5, COV2_SCALE(d)),
        new THREE.Vector3(+0.5, -0.5, COV2_SCALE(d))
      );
    }
  }

  // Draw line in 3d space
  function drawLine(material, start, end) {
    // Create geometry from start to end point
    let geometry = new THREE.Geometry();
    geometry.vertices.push(start);
    geometry.vertices.push(end);

    // Create line from geometry and add to scene
    let line = new THREE.Line(geometry, material);
    SCENE.add(line);
  }

  // Compute array of readable tick values between min (inclusive) and max (exclusive) of length less than count
  function getTickValues(min, max, count, minInterval) {
    const pattern = [5, 2, 1];
    let tickValues;
    let range = max - min;
    let pow = Math.floor(Math.log10(range));
    let p = 0;
    let interval = pattern[p] * Math.pow(10, pow);

    do {
      tickValues = d3.range(min, max, interval);

      if (p == 2) {
        p = 0;
        pow--;
      } else {
        p++;
      }

      interval = pattern[p] * Math.pow(10, pow);
    } while (d3.range(min, max, interval).length <= count && interval >= minInterval);

    return tickValues;
  }

  // Set XY values of element in window given XYZ in world coordinates
  function setXY() {
    const vector = this.position.clone();
    const canvas = RENDERER.domElement;

    vector.project(CAMERA);

    vector.x = Math.round(
      (0.5 + vector.x / 2) * (canvas.width / window.devicePixelRatio)
    );
    vector.y = Math.round(
      (0.5 - vector.y / 2) * (canvas.height / window.devicePixelRatio)
    );

    d3.select(this)
      .style("top", vector.y + "px")
      .style("left", vector.x + "px");
  }

  // Determine whether to display text based on text position and camera position
  function setDisplay() {
    const vector = this.position.clone();
    const camToText = CAMERA.position.distanceTo(vector);

    vector.project(CAMERA);

    // Update text raycaster with new mouse and camera location
    TEXT_RAYCASTER.setFromCamera(vector, CAMERA);

    // Get intersections from raycaster
    const intersects = TEXT_RAYCASTER.intersectObjects(GEOMETRIES);

    let intersected = false;
    for (let i = 0; i < intersects.length; i++) {
      if (intersects[i].distance < camToText) {
        intersected = true;
        break;
      }
    }

    return intersected || CAMERA.position.length() < this.position.length()
      ? "none"
      : "initial";
  }
});
</script>
<div class="container">
  <canvas></canvas>
  <button class="control-reset" onclick="controlReset();">Reset Camera</button>
  <div class="tooltip-container">
    <div class="tooltip-row">
      <p class="tooltip-value cov1"></p>
    </div>
    <div class="tooltip-row">
      <p class="tooltip-value cov2"></p>
    </div>
    <div class="tooltip-row">
      <p class="tooltip-value pred"></p>
    </div>
    <div class="tooltip-row">
      <p class="tooltip-value resid"></p>
    </div>
  </div>
</div>
</body>
</html>
